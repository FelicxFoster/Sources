<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Introduction &mdash; test_docs 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="test_docs 1.0 documentation" href="index.html" />
    <link rel="next" title="&lt;no title&gt;" href="installation.html" />
    <link rel="prev" title="Hey! Welcome to my document." href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="installation.html" title="&lt;no title&gt;"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Hey! Welcome to my document."
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">test_docs 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<p>Application servers such as Django and Ruby-on-Rails have been developed without intention to create
long living connections. Therefore these frameworks are not a good fit for web applications, which
shall react on asynchronous events initiated by the server. One feasible solution for clients
wishing to be notified for events is to continuously poll the server using an XMLHttpRequest (Ajax).
This however produces a lot of traffic, and depending on the granularity of the polling interval,
it is not a viable solution for real time events such as chat applications or browser based
multiplayer games.</p>
<p>Web application written in Python usually use WSGI as the communication layer between the
webserver and themselves. WSGI is a stateless protocol which defines how to handle requests and
making responses in a simple way abstracted from the HTTP protocol, but by design it does not
support non-blocking requests.</p>
<div class="section" id="the-wsgi-protocol-can-not-support-websockets">
<h2>The WSGI protocol can not support websockets<a class="headerlink" href="#the-wsgi-protocol-can-not-support-websockets" title="Permalink to this headline">¶</a></h2>
<p>In Django, the web server accepts an incoming request, sets up a WSGI dictionary which then is
passed to the application server. There the HTTP headers and the payload is created and immediately
afterwards the request is finished and flushed to the client. This processing typically requires
a few dozen milliseconds. The throughput, such a server can handle, is the average response
time multiplied by the number of concurrent workers. Each worker requires its own thread/process
and a good rule of thumb is to configure not more than twice as many workers as the number of cores
available on that host. Otherwise you will see a decrease in overall performance, caused by too
many context switches, for which the scheduler of the operating system is responsible.</p>
<p>Due to this workflow, it is almost impossible to add support for long term connections, such as
websockets, on top of the WSGI protocol specification. Therefore most websocket implementations go
for another approach. The websocket connection is controlled by a service running side by side
with the default application server. Here, a webserver with support for long term connections,
dispatches the requests from the clients.</p>
<p>A webserver able to dispatch websocket requests is the <a class="reference external" href="http://nginx.com/">NGiNX</a> server. Normal requests are sent to
Django using the WSGI protocol, whereas the long living websocket connections are passed over to
a special service responsible only for that.</p>
<p>A typical implementation proposal is to use <a class="reference external" href="http://socket.io/">socket.io</a> running inside a <a class="reference external" href="http://nodejs.org/">NodeJS</a> loop.</p>
<p><img alt="websocket-nodejs" src="_static/websocket-nodejs.png" /></p>
<p>Here, <strong>Django</strong> communicates with <strong>Node.JS</strong> using a RESTful API. This however is hard to maintain
because it pulls in two completely different technologies. In alternative proposals, other Python
based asynchronous event frameworks such as <a class="reference external" href="http://www.tornadoweb.org/">Tornado</a> or <a class="reference external" href="http://twistedmatrix.com/">Twisted</a> are used. But they all look like
makeshift solutions, since one has to run a second framework side by side with <strong>Django</strong>. This
makes the project dependent on another infrastructure and thus harder to maintain. Moreover, having
to run two concurrent frameworks can be quite embarrassing during application development,
specially while debugging code.</p>
</div>
<div class="section" id="uwsgi">
<h2>uWSGI<a class="headerlink" href="#uwsgi" title="Permalink to this headline">¶</a></h2>
<p>While searching for a simpler solution, I found out that <a class="reference external" href="http://uwsgi-docs.readthedocs.org/en/latest/WebSockets.html">uWSGI offers websockets</a> right out of
the box. With <a class="reference external" href="http://redis.io/">Redis</a> as a message queue, and a few lines of Python code, one can bidirectionally
communicate with any WSGI based framework, for instance <strong>Django</strong>. Of course, here it also is
prohibitive to create a new thread for each open websocket connection. Therefore that part of the
code runs in one single thread/process for all open connections in a cooperative concurrency mode
using the excellent <a class="reference external" href="http://www.gevent.org/">gevent</a> and <a class="reference external" href="http://greenlet.readthedocs.org/">greenlet</a> libraries.</p>
<p>This approach has some advantages:</p>
<ul>
<li><p class="first">It is simpler to implement.</p>
</li>
<li><dl class="first docutils">
<dt>The asynchronous I/O loop handling websockets can run</dt>
<dd><ul class="first last simple">
<li>inside Django with <code class="docutils literal"><span class="pre">./manage.py</span> <span class="pre">runserver</span></code>, giving full debugging control.</li>
<li>as a stand alone HTTP server, using uWSGI.</li>
<li>using NGiNX or Apache (&gt;= 2.4) as proxy in two decoupled loops, one for WSGI and one for
websocket HTTP in front of two separate uWSGI workers.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">The whole Django API is available in this loop, provided that no blocking calls are made.
Therefore the websocket code can access the Django configuration, the user and the session cache,
etc.</p>
</li>
</ul>
</div>
<div class="section" id="using-redis-as-a-message-queue">
<h2>Using Redis as a message queue<a class="headerlink" href="#using-redis-as-a-message-queue" title="Permalink to this headline">¶</a></h2>
<p>One might argue that all this is not as simple, since an additional service - the Redis data server
- must run side by side with Django. Websockets are bidirectional but their normal use case is to
trigger server initiated events on the client. Although the other direction is possible, it can
be handled much easier using Ajax - adding an additional TCP/IP handshake.</p>
<p>Here, the only &#8220;stay in touch with the client&#8221; is the file descriptor attached to the websocket.
And since we speak about thousands of open connections, the footprint in terms of memory and CPU
resources must be brought down to a minimum. In this implementation, only one open file handle
is required for each open websocket connection.</p>
<p>Productive webservers require some kind of session store anyway. This can be a <a class="reference external" href="http://memcached.org/">memcached</a> or a
Redis data server. Therefore, such a service must run anyway and if we can choose between one
of them, we shall use one with integrated message queuing support. When using Redis for caching and
as a session store, we practically get the message queue for free.</p>
<div class="section" id="scalability">
<h3>Scalability<a class="headerlink" href="#scalability" title="Permalink to this headline">¶</a></h3>
<p>One of the nice features of Redis is its infinite scalability. If one Redis server can&#8217;t handle its
workload, interconnect it with another one and all events and messages are mirrored across this
network. Since <strong>django-websocket-redis</strong> can be deployed multiple times and as self-contained
Django applications, this configuration can scale infinitely, just interconnect the Redis servers
to each other.</p>
<p>On the main entry point of your site, add a loadbalancer capable of proxying the websocket protocol.
This can be any OSI level 4 loadbalancer such as the <a class="reference external" href="http://www.linuxvirtualserver.org/">Linux Virtual Server</a> project, or if you
prefer OSI level 7, the excellent <a class="reference external" href="http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/">HAProxy</a>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Introduction</a><ul>
<li><a class="reference internal" href="#the-wsgi-protocol-can-not-support-websockets">The WSGI protocol can not support websockets</a></li>
<li><a class="reference internal" href="#uwsgi">uWSGI</a></li>
<li><a class="reference internal" href="#using-redis-as-a-message-queue">Using Redis as a message queue</a><ul>
<li><a class="reference internal" href="#scalability">Scalability</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Hey! Welcome to my document.</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="installation.html"
                        title="next chapter">&lt;no title&gt;</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/introduction.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="installation.html" title="&lt;no title&gt;"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Hey! Welcome to my document."
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">test_docs 1.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, zoro.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>